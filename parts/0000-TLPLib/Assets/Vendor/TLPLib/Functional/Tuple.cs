/* This code is autogenerated from tuples.cs */
namespace System {

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1> :
IComparable<Tpl<P1>>, IEquatable<Tpl<P1>> {
  public readonly P1 _1;

  public Tpl(P1 p1)
    { _1 = p1; }

  public void Deconstruct(out P1 _1) { _1 = this._1; }

  public override string ToString() => $"({_1})";

  public override bool Equals(object o) => o is Tpl<P1> && Equals((Tpl<P1>) o);
  public bool Equals(Tpl<P1> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1);
    return c;
  }

  public static bool operator == (Tpl<P1> lhs, Tpl<P1> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1> lhs, Tpl<P1> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1> lhs, Tpl<P1> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1> lhs, Tpl<P1> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1> lhs, Tpl<P1> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1> lhs, Tpl<P1> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2> :
IComparable<Tpl<P1, P2>>, IEquatable<Tpl<P1, P2>> {
  public readonly P1 _1; public readonly P2 _2;

  public Tpl(P1 p1, P2 p2)
    { _1 = p1; _2 = p2; }

  public void Deconstruct(out P1 _1, out P2 _2) { _1 = this._1; _2 = this._2; }

  public override string ToString() => $"({_1},{_2})";

  public override bool Equals(object o) => o is Tpl<P1, P2> && Equals((Tpl<P1, P2>) o);
  public bool Equals(Tpl<P1, P2> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2);
    return c;
  }

  public static bool operator == (Tpl<P1, P2> lhs, Tpl<P1, P2> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2> lhs, Tpl<P1, P2> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2> lhs, Tpl<P1, P2> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2> lhs, Tpl<P1, P2> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2> lhs, Tpl<P1, P2> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2> lhs, Tpl<P1, P2> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3> :
IComparable<Tpl<P1, P2, P3>>, IEquatable<Tpl<P1, P2, P3>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3;

  public Tpl(P1 p1, P2 p2, P3 p3)
    { _1 = p1; _2 = p2; _3 = p3; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3) { _1 = this._1; _2 = this._2; _3 = this._3; }

  public override string ToString() => $"({_1},{_2},{_3})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3> && Equals((Tpl<P1, P2, P3>) o);
  public bool Equals(Tpl<P1, P2, P3> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3> lhs, Tpl<P1, P2, P3> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3> lhs, Tpl<P1, P2, P3> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3> lhs, Tpl<P1, P2, P3> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3> lhs, Tpl<P1, P2, P3> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3> lhs, Tpl<P1, P2, P3> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3> lhs, Tpl<P1, P2, P3> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4> :
IComparable<Tpl<P1, P2, P3, P4>>, IEquatable<Tpl<P1, P2, P3, P4>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; }

  public override string ToString() => $"({_1},{_2},{_3},{_4})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4> && Equals((Tpl<P1, P2, P3, P4>) o);
  public bool Equals(Tpl<P1, P2, P3, P4> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4> lhs, Tpl<P1, P2, P3, P4> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4> lhs, Tpl<P1, P2, P3, P4> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4> lhs, Tpl<P1, P2, P3, P4> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4> lhs, Tpl<P1, P2, P3, P4> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4> lhs, Tpl<P1, P2, P3, P4> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4> lhs, Tpl<P1, P2, P3, P4> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5> :
IComparable<Tpl<P1, P2, P3, P4, P5>>, IEquatable<Tpl<P1, P2, P3, P4, P5>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5> && Equals((Tpl<P1, P2, P3, P4, P5>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5> lhs, Tpl<P1, P2, P3, P4, P5> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5> lhs, Tpl<P1, P2, P3, P4, P5> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5> lhs, Tpl<P1, P2, P3, P4, P5> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5> lhs, Tpl<P1, P2, P3, P4, P5> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5> lhs, Tpl<P1, P2, P3, P4, P5> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5> lhs, Tpl<P1, P2, P3, P4, P5> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6> && Equals((Tpl<P1, P2, P3, P4, P5, P6>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6> lhs, Tpl<P1, P2, P3, P4, P5, P6> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6> lhs, Tpl<P1, P2, P3, P4, P5, P6> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6> lhs, Tpl<P1, P2, P3, P4, P5, P6> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6> lhs, Tpl<P1, P2, P3, P4, P5, P6> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6> lhs, Tpl<P1, P2, P3, P4, P5, P6> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6> lhs, Tpl<P1, P2, P3, P4, P5, P6> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10; public readonly P11 _11;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; _11 = p11; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10, out P11 _11) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; _11 = this._11; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10},{_11})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10) &&
Smooth.Collections.EqComparer<P11>.Default.Equals(_11, t._11);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
hash = 29 * hash + Smooth.Collections.EqComparer<P11>.Default.GetHashCode(_11);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P11>.Default.Compare(_11, other._11);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10; public readonly P11 _11; public readonly P12 _12;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; _11 = p11; _12 = p12; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10, out P11 _11, out P12 _12) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; _11 = this._11; _12 = this._12; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10},{_11},{_12})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10) &&
Smooth.Collections.EqComparer<P11>.Default.Equals(_11, t._11) &&
Smooth.Collections.EqComparer<P12>.Default.Equals(_12, t._12);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
hash = 29 * hash + Smooth.Collections.EqComparer<P11>.Default.GetHashCode(_11);
hash = 29 * hash + Smooth.Collections.EqComparer<P12>.Default.GetHashCode(_12);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P11>.Default.Compare(_11, other._11); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P12>.Default.Compare(_12, other._12);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10; public readonly P11 _11; public readonly P12 _12; public readonly P13 _13;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; _11 = p11; _12 = p12; _13 = p13; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10, out P11 _11, out P12 _12, out P13 _13) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; _11 = this._11; _12 = this._12; _13 = this._13; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10},{_11},{_12},{_13})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10) &&
Smooth.Collections.EqComparer<P11>.Default.Equals(_11, t._11) &&
Smooth.Collections.EqComparer<P12>.Default.Equals(_12, t._12) &&
Smooth.Collections.EqComparer<P13>.Default.Equals(_13, t._13);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
hash = 29 * hash + Smooth.Collections.EqComparer<P11>.Default.GetHashCode(_11);
hash = 29 * hash + Smooth.Collections.EqComparer<P12>.Default.GetHashCode(_12);
hash = 29 * hash + Smooth.Collections.EqComparer<P13>.Default.GetHashCode(_13);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P11>.Default.Compare(_11, other._11); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P12>.Default.Compare(_12, other._12); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P13>.Default.Compare(_13, other._13);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10; public readonly P11 _11; public readonly P12 _12; public readonly P13 _13; public readonly P14 _14;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; _11 = p11; _12 = p12; _13 = p13; _14 = p14; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10, out P11 _11, out P12 _12, out P13 _13, out P14 _14) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; _11 = this._11; _12 = this._12; _13 = this._13; _14 = this._14; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10},{_11},{_12},{_13},{_14})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10) &&
Smooth.Collections.EqComparer<P11>.Default.Equals(_11, t._11) &&
Smooth.Collections.EqComparer<P12>.Default.Equals(_12, t._12) &&
Smooth.Collections.EqComparer<P13>.Default.Equals(_13, t._13) &&
Smooth.Collections.EqComparer<P14>.Default.Equals(_14, t._14);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
hash = 29 * hash + Smooth.Collections.EqComparer<P11>.Default.GetHashCode(_11);
hash = 29 * hash + Smooth.Collections.EqComparer<P12>.Default.GetHashCode(_12);
hash = 29 * hash + Smooth.Collections.EqComparer<P13>.Default.GetHashCode(_13);
hash = 29 * hash + Smooth.Collections.EqComparer<P14>.Default.GetHashCode(_14);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P11>.Default.Compare(_11, other._11); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P12>.Default.Compare(_12, other._12); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P13>.Default.Compare(_13, other._13); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P14>.Default.Compare(_14, other._14);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10; public readonly P11 _11; public readonly P12 _12; public readonly P13 _13; public readonly P14 _14; public readonly P15 _15;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; _11 = p11; _12 = p12; _13 = p13; _14 = p14; _15 = p15; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10, out P11 _11, out P12 _12, out P13 _13, out P14 _14, out P15 _15) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; _11 = this._11; _12 = this._12; _13 = this._13; _14 = this._14; _15 = this._15; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10},{_11},{_12},{_13},{_14},{_15})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10) &&
Smooth.Collections.EqComparer<P11>.Default.Equals(_11, t._11) &&
Smooth.Collections.EqComparer<P12>.Default.Equals(_12, t._12) &&
Smooth.Collections.EqComparer<P13>.Default.Equals(_13, t._13) &&
Smooth.Collections.EqComparer<P14>.Default.Equals(_14, t._14) &&
Smooth.Collections.EqComparer<P15>.Default.Equals(_15, t._15);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
hash = 29 * hash + Smooth.Collections.EqComparer<P11>.Default.GetHashCode(_11);
hash = 29 * hash + Smooth.Collections.EqComparer<P12>.Default.GetHashCode(_12);
hash = 29 * hash + Smooth.Collections.EqComparer<P13>.Default.GetHashCode(_13);
hash = 29 * hash + Smooth.Collections.EqComparer<P14>.Default.GetHashCode(_14);
hash = 29 * hash + Smooth.Collections.EqComparer<P15>.Default.GetHashCode(_15);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P11>.Default.Compare(_11, other._11); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P12>.Default.Compare(_12, other._12); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P13>.Default.Compare(_13, other._13); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P14>.Default.Compare(_14, other._14); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P15>.Default.Compare(_15, other._15);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10; public readonly P11 _11; public readonly P12 _12; public readonly P13 _13; public readonly P14 _14; public readonly P15 _15; public readonly P16 _16;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15, P16 p16)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; _11 = p11; _12 = p12; _13 = p13; _14 = p14; _15 = p15; _16 = p16; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10, out P11 _11, out P12 _12, out P13 _13, out P14 _14, out P15 _15, out P16 _16) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; _11 = this._11; _12 = this._12; _13 = this._13; _14 = this._14; _15 = this._15; _16 = this._16; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10},{_11},{_12},{_13},{_14},{_15},{_16})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10) &&
Smooth.Collections.EqComparer<P11>.Default.Equals(_11, t._11) &&
Smooth.Collections.EqComparer<P12>.Default.Equals(_12, t._12) &&
Smooth.Collections.EqComparer<P13>.Default.Equals(_13, t._13) &&
Smooth.Collections.EqComparer<P14>.Default.Equals(_14, t._14) &&
Smooth.Collections.EqComparer<P15>.Default.Equals(_15, t._15) &&
Smooth.Collections.EqComparer<P16>.Default.Equals(_16, t._16);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
hash = 29 * hash + Smooth.Collections.EqComparer<P11>.Default.GetHashCode(_11);
hash = 29 * hash + Smooth.Collections.EqComparer<P12>.Default.GetHashCode(_12);
hash = 29 * hash + Smooth.Collections.EqComparer<P13>.Default.GetHashCode(_13);
hash = 29 * hash + Smooth.Collections.EqComparer<P14>.Default.GetHashCode(_14);
hash = 29 * hash + Smooth.Collections.EqComparer<P15>.Default.GetHashCode(_15);
hash = 29 * hash + Smooth.Collections.EqComparer<P16>.Default.GetHashCode(_16);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P11>.Default.Compare(_11, other._11); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P12>.Default.Compare(_12, other._12); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P13>.Default.Compare(_13, other._13); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P14>.Default.Compare(_14, other._14); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P15>.Default.Compare(_15, other._15); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P16>.Default.Compare(_16, other._16);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10; public readonly P11 _11; public readonly P12 _12; public readonly P13 _13; public readonly P14 _14; public readonly P15 _15; public readonly P16 _16; public readonly P17 _17;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15, P16 p16, P17 p17)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; _11 = p11; _12 = p12; _13 = p13; _14 = p14; _15 = p15; _16 = p16; _17 = p17; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10, out P11 _11, out P12 _12, out P13 _13, out P14 _14, out P15 _15, out P16 _16, out P17 _17) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; _11 = this._11; _12 = this._12; _13 = this._13; _14 = this._14; _15 = this._15; _16 = this._16; _17 = this._17; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10},{_11},{_12},{_13},{_14},{_15},{_16},{_17})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10) &&
Smooth.Collections.EqComparer<P11>.Default.Equals(_11, t._11) &&
Smooth.Collections.EqComparer<P12>.Default.Equals(_12, t._12) &&
Smooth.Collections.EqComparer<P13>.Default.Equals(_13, t._13) &&
Smooth.Collections.EqComparer<P14>.Default.Equals(_14, t._14) &&
Smooth.Collections.EqComparer<P15>.Default.Equals(_15, t._15) &&
Smooth.Collections.EqComparer<P16>.Default.Equals(_16, t._16) &&
Smooth.Collections.EqComparer<P17>.Default.Equals(_17, t._17);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
hash = 29 * hash + Smooth.Collections.EqComparer<P11>.Default.GetHashCode(_11);
hash = 29 * hash + Smooth.Collections.EqComparer<P12>.Default.GetHashCode(_12);
hash = 29 * hash + Smooth.Collections.EqComparer<P13>.Default.GetHashCode(_13);
hash = 29 * hash + Smooth.Collections.EqComparer<P14>.Default.GetHashCode(_14);
hash = 29 * hash + Smooth.Collections.EqComparer<P15>.Default.GetHashCode(_15);
hash = 29 * hash + Smooth.Collections.EqComparer<P16>.Default.GetHashCode(_16);
hash = 29 * hash + Smooth.Collections.EqComparer<P17>.Default.GetHashCode(_17);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P11>.Default.Compare(_11, other._11); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P12>.Default.Compare(_12, other._12); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P13>.Default.Compare(_13, other._13); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P14>.Default.Compare(_14, other._14); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P15>.Default.Compare(_15, other._15); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P16>.Default.Compare(_16, other._16); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P17>.Default.Compare(_17, other._17);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10; public readonly P11 _11; public readonly P12 _12; public readonly P13 _13; public readonly P14 _14; public readonly P15 _15; public readonly P16 _16; public readonly P17 _17; public readonly P18 _18;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15, P16 p16, P17 p17, P18 p18)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; _11 = p11; _12 = p12; _13 = p13; _14 = p14; _15 = p15; _16 = p16; _17 = p17; _18 = p18; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10, out P11 _11, out P12 _12, out P13 _13, out P14 _14, out P15 _15, out P16 _16, out P17 _17, out P18 _18) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; _11 = this._11; _12 = this._12; _13 = this._13; _14 = this._14; _15 = this._15; _16 = this._16; _17 = this._17; _18 = this._18; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10},{_11},{_12},{_13},{_14},{_15},{_16},{_17},{_18})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10) &&
Smooth.Collections.EqComparer<P11>.Default.Equals(_11, t._11) &&
Smooth.Collections.EqComparer<P12>.Default.Equals(_12, t._12) &&
Smooth.Collections.EqComparer<P13>.Default.Equals(_13, t._13) &&
Smooth.Collections.EqComparer<P14>.Default.Equals(_14, t._14) &&
Smooth.Collections.EqComparer<P15>.Default.Equals(_15, t._15) &&
Smooth.Collections.EqComparer<P16>.Default.Equals(_16, t._16) &&
Smooth.Collections.EqComparer<P17>.Default.Equals(_17, t._17) &&
Smooth.Collections.EqComparer<P18>.Default.Equals(_18, t._18);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
hash = 29 * hash + Smooth.Collections.EqComparer<P11>.Default.GetHashCode(_11);
hash = 29 * hash + Smooth.Collections.EqComparer<P12>.Default.GetHashCode(_12);
hash = 29 * hash + Smooth.Collections.EqComparer<P13>.Default.GetHashCode(_13);
hash = 29 * hash + Smooth.Collections.EqComparer<P14>.Default.GetHashCode(_14);
hash = 29 * hash + Smooth.Collections.EqComparer<P15>.Default.GetHashCode(_15);
hash = 29 * hash + Smooth.Collections.EqComparer<P16>.Default.GetHashCode(_16);
hash = 29 * hash + Smooth.Collections.EqComparer<P17>.Default.GetHashCode(_17);
hash = 29 * hash + Smooth.Collections.EqComparer<P18>.Default.GetHashCode(_18);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P11>.Default.Compare(_11, other._11); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P12>.Default.Compare(_12, other._12); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P13>.Default.Compare(_13, other._13); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P14>.Default.Compare(_14, other._14); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P15>.Default.Compare(_15, other._15); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P16>.Default.Compare(_16, other._16); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P17>.Default.Compare(_17, other._17); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P18>.Default.Compare(_18, other._18);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10; public readonly P11 _11; public readonly P12 _12; public readonly P13 _13; public readonly P14 _14; public readonly P15 _15; public readonly P16 _16; public readonly P17 _17; public readonly P18 _18; public readonly P19 _19;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15, P16 p16, P17 p17, P18 p18, P19 p19)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; _11 = p11; _12 = p12; _13 = p13; _14 = p14; _15 = p15; _16 = p16; _17 = p17; _18 = p18; _19 = p19; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10, out P11 _11, out P12 _12, out P13 _13, out P14 _14, out P15 _15, out P16 _16, out P17 _17, out P18 _18, out P19 _19) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; _11 = this._11; _12 = this._12; _13 = this._13; _14 = this._14; _15 = this._15; _16 = this._16; _17 = this._17; _18 = this._18; _19 = this._19; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10},{_11},{_12},{_13},{_14},{_15},{_16},{_17},{_18},{_19})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10) &&
Smooth.Collections.EqComparer<P11>.Default.Equals(_11, t._11) &&
Smooth.Collections.EqComparer<P12>.Default.Equals(_12, t._12) &&
Smooth.Collections.EqComparer<P13>.Default.Equals(_13, t._13) &&
Smooth.Collections.EqComparer<P14>.Default.Equals(_14, t._14) &&
Smooth.Collections.EqComparer<P15>.Default.Equals(_15, t._15) &&
Smooth.Collections.EqComparer<P16>.Default.Equals(_16, t._16) &&
Smooth.Collections.EqComparer<P17>.Default.Equals(_17, t._17) &&
Smooth.Collections.EqComparer<P18>.Default.Equals(_18, t._18) &&
Smooth.Collections.EqComparer<P19>.Default.Equals(_19, t._19);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
hash = 29 * hash + Smooth.Collections.EqComparer<P11>.Default.GetHashCode(_11);
hash = 29 * hash + Smooth.Collections.EqComparer<P12>.Default.GetHashCode(_12);
hash = 29 * hash + Smooth.Collections.EqComparer<P13>.Default.GetHashCode(_13);
hash = 29 * hash + Smooth.Collections.EqComparer<P14>.Default.GetHashCode(_14);
hash = 29 * hash + Smooth.Collections.EqComparer<P15>.Default.GetHashCode(_15);
hash = 29 * hash + Smooth.Collections.EqComparer<P16>.Default.GetHashCode(_16);
hash = 29 * hash + Smooth.Collections.EqComparer<P17>.Default.GetHashCode(_17);
hash = 29 * hash + Smooth.Collections.EqComparer<P18>.Default.GetHashCode(_18);
hash = 29 * hash + Smooth.Collections.EqComparer<P19>.Default.GetHashCode(_19);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P11>.Default.Compare(_11, other._11); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P12>.Default.Compare(_12, other._12); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P13>.Default.Compare(_13, other._13); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P14>.Default.Compare(_14, other._14); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P15>.Default.Compare(_15, other._15); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P16>.Default.Compare(_16, other._16); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P17>.Default.Compare(_17, other._17); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P18>.Default.Compare(_18, other._18); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P19>.Default.Compare(_19, other._19);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10; public readonly P11 _11; public readonly P12 _12; public readonly P13 _13; public readonly P14 _14; public readonly P15 _15; public readonly P16 _16; public readonly P17 _17; public readonly P18 _18; public readonly P19 _19; public readonly P20 _20;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15, P16 p16, P17 p17, P18 p18, P19 p19, P20 p20)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; _11 = p11; _12 = p12; _13 = p13; _14 = p14; _15 = p15; _16 = p16; _17 = p17; _18 = p18; _19 = p19; _20 = p20; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10, out P11 _11, out P12 _12, out P13 _13, out P14 _14, out P15 _15, out P16 _16, out P17 _17, out P18 _18, out P19 _19, out P20 _20) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; _11 = this._11; _12 = this._12; _13 = this._13; _14 = this._14; _15 = this._15; _16 = this._16; _17 = this._17; _18 = this._18; _19 = this._19; _20 = this._20; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10},{_11},{_12},{_13},{_14},{_15},{_16},{_17},{_18},{_19},{_20})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10) &&
Smooth.Collections.EqComparer<P11>.Default.Equals(_11, t._11) &&
Smooth.Collections.EqComparer<P12>.Default.Equals(_12, t._12) &&
Smooth.Collections.EqComparer<P13>.Default.Equals(_13, t._13) &&
Smooth.Collections.EqComparer<P14>.Default.Equals(_14, t._14) &&
Smooth.Collections.EqComparer<P15>.Default.Equals(_15, t._15) &&
Smooth.Collections.EqComparer<P16>.Default.Equals(_16, t._16) &&
Smooth.Collections.EqComparer<P17>.Default.Equals(_17, t._17) &&
Smooth.Collections.EqComparer<P18>.Default.Equals(_18, t._18) &&
Smooth.Collections.EqComparer<P19>.Default.Equals(_19, t._19) &&
Smooth.Collections.EqComparer<P20>.Default.Equals(_20, t._20);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
hash = 29 * hash + Smooth.Collections.EqComparer<P11>.Default.GetHashCode(_11);
hash = 29 * hash + Smooth.Collections.EqComparer<P12>.Default.GetHashCode(_12);
hash = 29 * hash + Smooth.Collections.EqComparer<P13>.Default.GetHashCode(_13);
hash = 29 * hash + Smooth.Collections.EqComparer<P14>.Default.GetHashCode(_14);
hash = 29 * hash + Smooth.Collections.EqComparer<P15>.Default.GetHashCode(_15);
hash = 29 * hash + Smooth.Collections.EqComparer<P16>.Default.GetHashCode(_16);
hash = 29 * hash + Smooth.Collections.EqComparer<P17>.Default.GetHashCode(_17);
hash = 29 * hash + Smooth.Collections.EqComparer<P18>.Default.GetHashCode(_18);
hash = 29 * hash + Smooth.Collections.EqComparer<P19>.Default.GetHashCode(_19);
hash = 29 * hash + Smooth.Collections.EqComparer<P20>.Default.GetHashCode(_20);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P11>.Default.Compare(_11, other._11); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P12>.Default.Compare(_12, other._12); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P13>.Default.Compare(_13, other._13); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P14>.Default.Compare(_14, other._14); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P15>.Default.Compare(_15, other._15); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P16>.Default.Compare(_16, other._16); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P17>.Default.Compare(_17, other._17); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P18>.Default.Compare(_18, other._18); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P19>.Default.Compare(_19, other._19); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P20>.Default.Compare(_20, other._20);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10; public readonly P11 _11; public readonly P12 _12; public readonly P13 _13; public readonly P14 _14; public readonly P15 _15; public readonly P16 _16; public readonly P17 _17; public readonly P18 _18; public readonly P19 _19; public readonly P20 _20; public readonly P21 _21;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15, P16 p16, P17 p17, P18 p18, P19 p19, P20 p20, P21 p21)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; _11 = p11; _12 = p12; _13 = p13; _14 = p14; _15 = p15; _16 = p16; _17 = p17; _18 = p18; _19 = p19; _20 = p20; _21 = p21; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10, out P11 _11, out P12 _12, out P13 _13, out P14 _14, out P15 _15, out P16 _16, out P17 _17, out P18 _18, out P19 _19, out P20 _20, out P21 _21) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; _11 = this._11; _12 = this._12; _13 = this._13; _14 = this._14; _15 = this._15; _16 = this._16; _17 = this._17; _18 = this._18; _19 = this._19; _20 = this._20; _21 = this._21; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10},{_11},{_12},{_13},{_14},{_15},{_16},{_17},{_18},{_19},{_20},{_21})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10) &&
Smooth.Collections.EqComparer<P11>.Default.Equals(_11, t._11) &&
Smooth.Collections.EqComparer<P12>.Default.Equals(_12, t._12) &&
Smooth.Collections.EqComparer<P13>.Default.Equals(_13, t._13) &&
Smooth.Collections.EqComparer<P14>.Default.Equals(_14, t._14) &&
Smooth.Collections.EqComparer<P15>.Default.Equals(_15, t._15) &&
Smooth.Collections.EqComparer<P16>.Default.Equals(_16, t._16) &&
Smooth.Collections.EqComparer<P17>.Default.Equals(_17, t._17) &&
Smooth.Collections.EqComparer<P18>.Default.Equals(_18, t._18) &&
Smooth.Collections.EqComparer<P19>.Default.Equals(_19, t._19) &&
Smooth.Collections.EqComparer<P20>.Default.Equals(_20, t._20) &&
Smooth.Collections.EqComparer<P21>.Default.Equals(_21, t._21);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
hash = 29 * hash + Smooth.Collections.EqComparer<P11>.Default.GetHashCode(_11);
hash = 29 * hash + Smooth.Collections.EqComparer<P12>.Default.GetHashCode(_12);
hash = 29 * hash + Smooth.Collections.EqComparer<P13>.Default.GetHashCode(_13);
hash = 29 * hash + Smooth.Collections.EqComparer<P14>.Default.GetHashCode(_14);
hash = 29 * hash + Smooth.Collections.EqComparer<P15>.Default.GetHashCode(_15);
hash = 29 * hash + Smooth.Collections.EqComparer<P16>.Default.GetHashCode(_16);
hash = 29 * hash + Smooth.Collections.EqComparer<P17>.Default.GetHashCode(_17);
hash = 29 * hash + Smooth.Collections.EqComparer<P18>.Default.GetHashCode(_18);
hash = 29 * hash + Smooth.Collections.EqComparer<P19>.Default.GetHashCode(_19);
hash = 29 * hash + Smooth.Collections.EqComparer<P20>.Default.GetHashCode(_20);
hash = 29 * hash + Smooth.Collections.EqComparer<P21>.Default.GetHashCode(_21);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P11>.Default.Compare(_11, other._11); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P12>.Default.Compare(_12, other._12); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P13>.Default.Compare(_13, other._13); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P14>.Default.Compare(_14, other._14); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P15>.Default.Compare(_15, other._15); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P16>.Default.Compare(_16, other._16); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P17>.Default.Compare(_17, other._17); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P18>.Default.Compare(_18, other._18); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P19>.Default.Compare(_19, other._19); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P20>.Default.Compare(_20, other._20); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P21>.Default.Compare(_21, other._21);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> rhs) => lhs.CompareTo(rhs) <= 0;
}

[Serializable] public
#if ENABLE_IL2CPP
  class
#else
  struct
#endif
       Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> :
IComparable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22>>, IEquatable<Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22>> {
  public readonly P1 _1; public readonly P2 _2; public readonly P3 _3; public readonly P4 _4; public readonly P5 _5; public readonly P6 _6; public readonly P7 _7; public readonly P8 _8; public readonly P9 _9; public readonly P10 _10; public readonly P11 _11; public readonly P12 _12; public readonly P13 _13; public readonly P14 _14; public readonly P15 _15; public readonly P16 _16; public readonly P17 _17; public readonly P18 _18; public readonly P19 _19; public readonly P20 _20; public readonly P21 _21; public readonly P22 _22;

  public Tpl(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15, P16 p16, P17 p17, P18 p18, P19 p19, P20 p20, P21 p21, P22 p22)
    { _1 = p1; _2 = p2; _3 = p3; _4 = p4; _5 = p5; _6 = p6; _7 = p7; _8 = p8; _9 = p9; _10 = p10; _11 = p11; _12 = p12; _13 = p13; _14 = p14; _15 = p15; _16 = p16; _17 = p17; _18 = p18; _19 = p19; _20 = p20; _21 = p21; _22 = p22; }

  public void Deconstruct(out P1 _1, out P2 _2, out P3 _3, out P4 _4, out P5 _5, out P6 _6, out P7 _7, out P8 _8, out P9 _9, out P10 _10, out P11 _11, out P12 _12, out P13 _13, out P14 _14, out P15 _15, out P16 _16, out P17 _17, out P18 _18, out P19 _19, out P20 _20, out P21 _21, out P22 _22) { _1 = this._1; _2 = this._2; _3 = this._3; _4 = this._4; _5 = this._5; _6 = this._6; _7 = this._7; _8 = this._8; _9 = this._9; _10 = this._10; _11 = this._11; _12 = this._12; _13 = this._13; _14 = this._14; _15 = this._15; _16 = this._16; _17 = this._17; _18 = this._18; _19 = this._19; _20 = this._20; _21 = this._21; _22 = this._22; }

  public override string ToString() => $"({_1},{_2},{_3},{_4},{_5},{_6},{_7},{_8},{_9},{_10},{_11},{_12},{_13},{_14},{_15},{_16},{_17},{_18},{_19},{_20},{_21},{_22})";

  public override bool Equals(object o) => o is Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> && Equals((Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22>) o);
  public bool Equals(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> t) => Smooth.Collections.EqComparer<P1>.Default.Equals(_1, t._1) &&
Smooth.Collections.EqComparer<P2>.Default.Equals(_2, t._2) &&
Smooth.Collections.EqComparer<P3>.Default.Equals(_3, t._3) &&
Smooth.Collections.EqComparer<P4>.Default.Equals(_4, t._4) &&
Smooth.Collections.EqComparer<P5>.Default.Equals(_5, t._5) &&
Smooth.Collections.EqComparer<P6>.Default.Equals(_6, t._6) &&
Smooth.Collections.EqComparer<P7>.Default.Equals(_7, t._7) &&
Smooth.Collections.EqComparer<P8>.Default.Equals(_8, t._8) &&
Smooth.Collections.EqComparer<P9>.Default.Equals(_9, t._9) &&
Smooth.Collections.EqComparer<P10>.Default.Equals(_10, t._10) &&
Smooth.Collections.EqComparer<P11>.Default.Equals(_11, t._11) &&
Smooth.Collections.EqComparer<P12>.Default.Equals(_12, t._12) &&
Smooth.Collections.EqComparer<P13>.Default.Equals(_13, t._13) &&
Smooth.Collections.EqComparer<P14>.Default.Equals(_14, t._14) &&
Smooth.Collections.EqComparer<P15>.Default.Equals(_15, t._15) &&
Smooth.Collections.EqComparer<P16>.Default.Equals(_16, t._16) &&
Smooth.Collections.EqComparer<P17>.Default.Equals(_17, t._17) &&
Smooth.Collections.EqComparer<P18>.Default.Equals(_18, t._18) &&
Smooth.Collections.EqComparer<P19>.Default.Equals(_19, t._19) &&
Smooth.Collections.EqComparer<P20>.Default.Equals(_20, t._20) &&
Smooth.Collections.EqComparer<P21>.Default.Equals(_21, t._21) &&
Smooth.Collections.EqComparer<P22>.Default.Equals(_22, t._22);

  public override int GetHashCode() {
    unchecked {
      var hash = 17;
      hash = 29 * hash + Smooth.Collections.EqComparer<P1>.Default.GetHashCode(_1);
hash = 29 * hash + Smooth.Collections.EqComparer<P2>.Default.GetHashCode(_2);
hash = 29 * hash + Smooth.Collections.EqComparer<P3>.Default.GetHashCode(_3);
hash = 29 * hash + Smooth.Collections.EqComparer<P4>.Default.GetHashCode(_4);
hash = 29 * hash + Smooth.Collections.EqComparer<P5>.Default.GetHashCode(_5);
hash = 29 * hash + Smooth.Collections.EqComparer<P6>.Default.GetHashCode(_6);
hash = 29 * hash + Smooth.Collections.EqComparer<P7>.Default.GetHashCode(_7);
hash = 29 * hash + Smooth.Collections.EqComparer<P8>.Default.GetHashCode(_8);
hash = 29 * hash + Smooth.Collections.EqComparer<P9>.Default.GetHashCode(_9);
hash = 29 * hash + Smooth.Collections.EqComparer<P10>.Default.GetHashCode(_10);
hash = 29 * hash + Smooth.Collections.EqComparer<P11>.Default.GetHashCode(_11);
hash = 29 * hash + Smooth.Collections.EqComparer<P12>.Default.GetHashCode(_12);
hash = 29 * hash + Smooth.Collections.EqComparer<P13>.Default.GetHashCode(_13);
hash = 29 * hash + Smooth.Collections.EqComparer<P14>.Default.GetHashCode(_14);
hash = 29 * hash + Smooth.Collections.EqComparer<P15>.Default.GetHashCode(_15);
hash = 29 * hash + Smooth.Collections.EqComparer<P16>.Default.GetHashCode(_16);
hash = 29 * hash + Smooth.Collections.EqComparer<P17>.Default.GetHashCode(_17);
hash = 29 * hash + Smooth.Collections.EqComparer<P18>.Default.GetHashCode(_18);
hash = 29 * hash + Smooth.Collections.EqComparer<P19>.Default.GetHashCode(_19);
hash = 29 * hash + Smooth.Collections.EqComparer<P20>.Default.GetHashCode(_20);
hash = 29 * hash + Smooth.Collections.EqComparer<P21>.Default.GetHashCode(_21);
hash = 29 * hash + Smooth.Collections.EqComparer<P22>.Default.GetHashCode(_22);
      return hash;
    }
  }

  public int CompareTo(Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> other) {
    var c = Smooth.Collections.Comparer<P1>.Default.Compare(_1, other._1); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P2>.Default.Compare(_2, other._2); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P3>.Default.Compare(_3, other._3); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P4>.Default.Compare(_4, other._4); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P5>.Default.Compare(_5, other._5); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P6>.Default.Compare(_6, other._6); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P7>.Default.Compare(_7, other._7); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P8>.Default.Compare(_8, other._8); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P9>.Default.Compare(_9, other._9); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P10>.Default.Compare(_10, other._10); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P11>.Default.Compare(_11, other._11); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P12>.Default.Compare(_12, other._12); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P13>.Default.Compare(_13, other._13); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P14>.Default.Compare(_14, other._14); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P15>.Default.Compare(_15, other._15); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P16>.Default.Compare(_16, other._16); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P17>.Default.Compare(_17, other._17); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P18>.Default.Compare(_18, other._18); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P19>.Default.Compare(_19, other._19); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P20>.Default.Compare(_20, other._20); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P21>.Default.Compare(_21, other._21); if (c != 0) { return c; }
c = Smooth.Collections.Comparer<P22>.Default.Compare(_22, other._22);
    return c;
  }

  public static bool operator == (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> rhs) => lhs.Equals(rhs);
  public static bool operator != (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> rhs) => !lhs.Equals(rhs);
  public static bool operator > (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> rhs) => lhs.CompareTo(rhs) > 0;
  public static bool operator < (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> rhs) => lhs.CompareTo(rhs) < 0;
  public static bool operator >= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> rhs) => lhs.CompareTo(rhs) >= 0;
  public static bool operator <= (Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> lhs, Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> rhs) => lhs.CompareTo(rhs) <= 0;
}

// We want to have as little methods on objects as possible due to how IL2CPP expands things.
public static class TupleGeneratedExts {

  public static Tpl<P1, P2> add<P1, P2>(this Tpl<P1> t, P2 a) =>
new Tpl<P1, P2>(t._1, a);
  public static Tpl<P2, P1> unshift<P1, P2>(this Tpl<P1> t, P2 a) =>
  new Tpl<P2, P1>(a, t._1);

  /// <summary>Unapply.</summary>
  public static void ua<P1>(this Tpl<P1> t, Action<P1> f) => f(t._1);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, R>(this Tpl<P1> t, Func<P1, R> f) => f(t._1);


  public static Tpl<P1, P2, P3> add<P1, P2, P3>(this Tpl<P1, P2> t, P3 a) =>
new Tpl<P1, P2, P3>(t._1, t._2, a);
  public static Tpl<P3, P1, P2> unshift<P1, P2, P3>(this Tpl<P1, P2> t, P3 a) =>
  new Tpl<P3, P1, P2>(a, t._1, t._2);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2>(this Tpl<P1, P2> t, Action<P1, P2> f) => f(t._1, t._2);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, R>(this Tpl<P1, P2> t, Func<P1, P2, R> f) => f(t._1, t._2);


  public static Tpl<P1, P2, P3, P4> add<P1, P2, P3, P4>(this Tpl<P1, P2, P3> t, P4 a) =>
new Tpl<P1, P2, P3, P4>(t._1, t._2, t._3, a);
  public static Tpl<P4, P1, P2, P3> unshift<P1, P2, P3, P4>(this Tpl<P1, P2, P3> t, P4 a) =>
  new Tpl<P4, P1, P2, P3>(a, t._1, t._2, t._3);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3>(this Tpl<P1, P2, P3> t, Action<P1, P2, P3> f) => f(t._1, t._2, t._3);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, R>(this Tpl<P1, P2, P3> t, Func<P1, P2, P3, R> f) => f(t._1, t._2, t._3);


  public static Tpl<P1, P2, P3, P4, P5> add<P1, P2, P3, P4, P5>(this Tpl<P1, P2, P3, P4> t, P5 a) =>
new Tpl<P1, P2, P3, P4, P5>(t._1, t._2, t._3, t._4, a);
  public static Tpl<P5, P1, P2, P3, P4> unshift<P1, P2, P3, P4, P5>(this Tpl<P1, P2, P3, P4> t, P5 a) =>
  new Tpl<P5, P1, P2, P3, P4>(a, t._1, t._2, t._3, t._4);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4>(this Tpl<P1, P2, P3, P4> t, Action<P1, P2, P3, P4> f) => f(t._1, t._2, t._3, t._4);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, R>(this Tpl<P1, P2, P3, P4> t, Func<P1, P2, P3, P4, R> f) => f(t._1, t._2, t._3, t._4);


  public static Tpl<P1, P2, P3, P4, P5, P6> add<P1, P2, P3, P4, P5, P6>(this Tpl<P1, P2, P3, P4, P5> t, P6 a) =>
new Tpl<P1, P2, P3, P4, P5, P6>(t._1, t._2, t._3, t._4, t._5, a);
  public static Tpl<P6, P1, P2, P3, P4, P5> unshift<P1, P2, P3, P4, P5, P6>(this Tpl<P1, P2, P3, P4, P5> t, P6 a) =>
  new Tpl<P6, P1, P2, P3, P4, P5>(a, t._1, t._2, t._3, t._4, t._5);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4, P5>(this Tpl<P1, P2, P3, P4, P5> t, Action<P1, P2, P3, P4, P5> f) => f(t._1, t._2, t._3, t._4, t._5);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, P5, R>(this Tpl<P1, P2, P3, P4, P5> t, Func<P1, P2, P3, P4, P5, R> f) => f(t._1, t._2, t._3, t._4, t._5);


  public static Tpl<P1, P2, P3, P4, P5, P6, P7> add<P1, P2, P3, P4, P5, P6, P7>(this Tpl<P1, P2, P3, P4, P5, P6> t, P7 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7>(t._1, t._2, t._3, t._4, t._5, t._6, a);
  public static Tpl<P7, P1, P2, P3, P4, P5, P6> unshift<P1, P2, P3, P4, P5, P6, P7>(this Tpl<P1, P2, P3, P4, P5, P6> t, P7 a) =>
  new Tpl<P7, P1, P2, P3, P4, P5, P6>(a, t._1, t._2, t._3, t._4, t._5, t._6);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4, P5, P6>(this Tpl<P1, P2, P3, P4, P5, P6> t, Action<P1, P2, P3, P4, P5, P6> f) => f(t._1, t._2, t._3, t._4, t._5, t._6);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, P5, P6, R>(this Tpl<P1, P2, P3, P4, P5, P6> t, Func<P1, P2, P3, P4, P5, P6, R> f) => f(t._1, t._2, t._3, t._4, t._5, t._6);


  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8> add<P1, P2, P3, P4, P5, P6, P7, P8>(this Tpl<P1, P2, P3, P4, P5, P6, P7> t, P8 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, a);
  public static Tpl<P8, P1, P2, P3, P4, P5, P6, P7> unshift<P1, P2, P3, P4, P5, P6, P7, P8>(this Tpl<P1, P2, P3, P4, P5, P6, P7> t, P8 a) =>
  new Tpl<P8, P1, P2, P3, P4, P5, P6, P7>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4, P5, P6, P7>(this Tpl<P1, P2, P3, P4, P5, P6, P7> t, Action<P1, P2, P3, P4, P5, P6, P7> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, P5, P6, P7, R>(this Tpl<P1, P2, P3, P4, P5, P6, P7> t, Func<P1, P2, P3, P4, P5, P6, P7, R> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7);


  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> add<P1, P2, P3, P4, P5, P6, P7, P8, P9>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8> t, P9 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, a);
  public static Tpl<P9, P1, P2, P3, P4, P5, P6, P7, P8> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8> t, P9 a) =>
  new Tpl<P9, P1, P2, P3, P4, P5, P6, P7, P8>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4, P5, P6, P7, P8>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8> t, Action<P1, P2, P3, P4, P5, P6, P7, P8> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, P5, P6, P7, P8, R>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8> t, Func<P1, P2, P3, P4, P5, P6, P7, P8, R> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8);


  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> t, P10 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, a);
  public static Tpl<P10, P1, P2, P3, P4, P5, P6, P7, P8, P9> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> t, P10 a) =>
  new Tpl<P10, P1, P2, P3, P4, P5, P6, P7, P8, P9>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4, P5, P6, P7, P8, P9>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> t, Action<P1, P2, P3, P4, P5, P6, P7, P8, P9> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, R>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9> t, Func<P1, P2, P3, P4, P5, P6, P7, P8, P9, R> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9);


  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> t, P11 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, a);
  public static Tpl<P11, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> t, P11 a) =>
  new Tpl<P11, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> t, Action<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, R>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> t, Func<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, R> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10);


  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> t, P12 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, a);
  public static Tpl<P12, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> t, P12 a) =>
  new Tpl<P12, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> t, Action<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, R>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11> t, Func<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, R> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11);


  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> t, P13 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, a);
  public static Tpl<P13, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> t, P13 a) =>
  new Tpl<P13, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> t, Action<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, R>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12> t, Func<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, R> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12);


  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> t, P14 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, a);
  public static Tpl<P14, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> t, P14 a) =>
  new Tpl<P14, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> t, Action<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, R>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> t, Func<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, R> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13);


  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> t, P15 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, a);
  public static Tpl<P15, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> t, P15 a) =>
  new Tpl<P15, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> t, Action<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, R>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14> t, Func<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, R> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14);


  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> t, P16 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, a);
  public static Tpl<P16, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> t, P16 a) =>
  new Tpl<P16, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> t, Action<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, R>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15> t, Func<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, R> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15);


  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> t, P17 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16, a);
  public static Tpl<P17, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> t, P17 a) =>
  new Tpl<P17, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16);

  /// <summary>Unapply.</summary>
  public static void ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> t, Action<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16);

  /// <summary>Unapply with function.</summary>
  public static R ua<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, R>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16> t, Func<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, R> f) => f(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16);


  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> t, P18 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16, t._17, a);
  public static Tpl<P18, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17> t, P18 a) =>
  new Tpl<P18, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16, t._17);

  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> t, P19 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16, t._17, t._18, a);
  public static Tpl<P19, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18> t, P19 a) =>
  new Tpl<P19, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16, t._17, t._18);

  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> t, P20 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16, t._17, t._18, t._19, a);
  public static Tpl<P20, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19> t, P20 a) =>
  new Tpl<P20, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16, t._17, t._18, t._19);

  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> t, P21 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16, t._17, t._18, t._19, t._20, a);
  public static Tpl<P21, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> t, P21 a) =>
  new Tpl<P21, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16, t._17, t._18, t._19, t._20);

  public static Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22> add<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> t, P22 a) =>
new Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22>(t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16, t._17, t._18, t._19, t._20, t._21, a);
  public static Tpl<P22, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> unshift<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22>(this Tpl<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21> t, P22 a) =>
  new Tpl<P22, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21>(a, t._1, t._2, t._3, t._4, t._5, t._6, t._7, t._8, t._9, t._10, t._11, t._12, t._13, t._14, t._15, t._16, t._17, t._18, t._19, t._20, t._21);
}
}

